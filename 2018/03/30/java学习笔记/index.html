<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> java入门学习笔记 · TsunaSun</title><meta name="description" content="java入门学习笔记 - Tsuna"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="TsunaSun"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="https://weibo.com/u/1964989721" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/TsunaSun" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">java入门学习笔记</h1><div class="post-info">Mar 30, 2018</div><div class="post-content"><p>总感觉java没有学好，重新看了一遍慕课上的java入门。想了一下还是自己做点笔记，概念的几天不看就容易忘。</p>
<h1 id="java入门第一季"><a href="#java入门第一季" class="headerlink" title="java入门第一季"></a>java入门第一季</h1><p>第一季都是一些简单的语法。有c语言基础，很快解决。</p>
<h1 id="java入门第二季"><a href="#java入门第二季" class="headerlink" title="java入门第二季"></a>java入门第二季</h1><p>第二季主要是面向对象的思想。以封装多态和继承为主。</p>
<h3 id="第一章-类和对象"><a href="#第一章-类和对象" class="headerlink" title="第一章 类和对象"></a>第一章 类和对象</h3><p>其他都好理解，一点就是静态吧。用 <code>static</code>修饰。<br><em>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</em></p>
<h3 id="第二章-封装"><a href="#第二章-封装" class="headerlink" title="第二章 封装"></a>第二章 封装</h3><p>封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>好处：1、只能通过规定的方法访问数据。<br>2、隐藏类的实例细节，方便修改和实现<br>如用<code>get/set</code>获取显示属性</p>
<p>this 关键字 :属性名往往与参数名相同，为了区分，就用到this关键字. this.screen代表当前对象的属性，this.方法名()则代表调用当前对象的方法.</p>
<p>内部类:<em>内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</em></p>
<ol>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便<br>内部类可分为以下几种：<br>成员内部类<br>静态内部类<br>方法内部类<br>匿名内部类<h3 id="第三章-继承"><a href="#第三章-继承" class="headerlink" title="第三章 继承"></a>第三章 继承</h3>重写和重载</li>
</ol>
<ul>
<li>重写方法的规则：</li>
</ul>
<p>1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。如果在子类中写了一个只有返回类型不同的函数，将不是重写，且会报错</p>
<p>3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p>
<p>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<ul>
<li>而重载的规则：</li>
</ul>
<p>1、必须具有不同的参数列表；</p>
<p>2、可以有不责骂的返回类型，只要参数列表不同就可以了；</p>
<p>3、可以有不同的访问修饰符；</p>
<p>4、可以抛出不同的异常；</p>
<ul>
<li>重写与重载的区别在于：</li>
</ul>
<p>重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。</p>
<p>用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般.</p>
<p>重写是除了函数体其他必须完全相同，如果参数不同则是重载，如果参数相同而返回类型不同则会报错<br>继承的初始化顺序<br>1.初始化父类再初始化子类。<br>2.先执行初始化对象中的属性，再执行构造方法中的初始化。<br>父类对象–&gt;属性初始化—&gt;构造方法<br>子类对象–&gt;属性初始化—&gt;构造方法<br>父类与子类之间的调用顺序（打印结果）<br>a) 父类静态代码块<br>b) 子类静态代码块<br>c) 父类构造方法<br>d) 子类构造方法<br>e) 子类普通方法<br>f) 重写父类的方法，则打印重写后的方法<br>inal关键字<br>表示“最终的”，即不可修改。<br>final可以修饰类、方法、属性和变量<br>1、修饰类：不允许被继承<br>2、修饰方法：不允许被重写<br>3、修饰属性：则该属性不会进行隐式初始化（不会自动初始化），需要手动初始化或者在构造方法中初始化 （但二者只能选一，即只能初始化一次后便不能更改）<br>4、修饰变量，只能在声明的时候赋一次值，成为常量。 （static final 会使其成为全局常量）<br>super<br>super关键字指的是父类<br>子类的构造的过程当中必须调用其父类的构造方法 相当于super();默认是调用无参的<br>如果子类的构造方法中没有显示调用父类的构造方法,系统会默认调用父类无参的构造方法.<br>如果要显示的调用父类的构造方法,必须在子类的构造方法第一行中添加super();<br>如果子类构造方法中既没有显示调用父类的构造方法,而父类又没有无参的构造方法,则编译出错,如果父类是定义了有参的构造方法,那么子类必须super.(父类的参数),或者父类中添加一个无参的构造方法,否则出错 因为默认调用的是super();是无参的。<br>一个类中没有定义构造方法,则系统会默认为此类定义一个无参的构造方法.如果自定义了一个带参的构造方法,则系统不会为其添加无参的构造方法.<br>Object方法<br>视频只讲了2个方法。其实有12个方法。<br><code>Object()</code><br>默认构造方法<br><code>clone()</code><br>创建并返回此对象的一个副本。<br><code>equals(Object obj)</code><br>指示某个其他对象是否与此对象“相等”。<br><code>finalize()</code><br>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。<br><code>getClass()</code><br>返回一个对象的运行时类。<br><code>hashCode()</code><br>返回该对象的哈希码值。<br><code>notify()</code><br>唤醒在此对象监视器上等待的单个线程。<br><code>notifyAll()</code><br>唤醒在此对象监视器上等待的所有线程。<br><code>toString()</code><br>返回该对象的字符串表示。<br><code>wait()</code><br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。<br><code>wait(long timeout)</code><br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。<br><code>wait(long timeout, int nanos)</code><br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<h3 id="第四章-多态"><a href="#第四章-多态" class="headerlink" title="第四章 多态"></a>第四章 多态</h3><p>多态： 指的是对象的多种形态<br>主要分为 引用多态 、方法多态<br>继承是多态的实现基础，别忘了子父类要有继承关系.<br>多态特性：</p>
<ul>
<li>一、引用多态<br>1.父类引用可以指向本类对象 Animal obj1 = new Animal();<br>2.父类引用可以指向子类对象 Animal obj2 = new Dog();<br>但是我们不能用子类的引用指向父类对象 Dog obj3 = new Animal();//错</li>
<li>二、方法多态<br>1.在父类Animal中定义一个eat()方法，输出一个语句(动物有吃的能力); 在子类Dog中重写eat()方法，输出一个语句（狗是吃肉的）; 那么我们在测试类main函数里面，如果obj1.eat() ，那么调用的是父类的方法. 若用obj2调用eat()方法，那么调用的是子类的方法.<br>2.还有一种情况，比如创建一个继承父类Animal的子类Cat ，但是Cat里并不重写继承的eat()方法. 然后，我们在测试类main函数里创建一个子类对象, Animal obj3 = new Cat(); 然后调用 obj3.eat(); 那么，结果调用的则是子类继承父类的方法. (输出结果：动物有吃的能力)<br>3.最后一种特殊情况，多态的特性是不能使用的. 若在子类添加一个独有的方法 public void watchDoor() ，含有一句输出语句(狗具有看门的能力); 那么我们在测试类的main函数当中(得先定义好对象Animal obj2 = new Dog() )，就不能用obj2.watchDoor()，即不能通过父类的引用调用子类的方法.</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/07/jdk降级/" class="prev">PREV</a><a href="/2018/03/29/java数组/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Tsuna</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>