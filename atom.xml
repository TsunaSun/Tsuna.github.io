<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-30T06:06:11.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java入门学习笔记</title>
    <link href="http://yoursite.com/2018/03/30/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/30/java学习笔记/</id>
    <published>2018-03-30T05:22:21.166Z</published>
    <updated>2018-03-30T06:06:11.887Z</updated>
    
    <content type="html"><![CDATA[<p>总感觉java没有学好，重新看了一遍慕课上的java入门。想了一下还是自己做点笔记，概念的几天不看就容易忘。</p><h3>java入门第一季</h3><p>第一季都是一些简单的语法。有c语言基础，很快解决。</p><h3>java入门第二季</h3><p>第二季主要是面向对象的思想。以封装多态和继承为主。</p><h2>第一章 类和对象</h2><p>其他都好理解，一点就是静态吧。用 <code>static</code>修饰。<em>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</em></p><h2>第二章 封装</h2><p>封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。好处：1、只能通过规定的方法访问数据。2、隐藏类的实例细节，方便修改和实现如用<code>get/set</code>获取显示属性</p><p>this 关键字 :属性名往往与参数名相同，为了区分，就用到this关键字. this.screen代表当前对象的属性，this.方法名()则代表调用当前对象的方法.</p><p>内部类:<em>内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</em></p><ol><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便内部类可分为以下几种：成员内部类静态内部类方法内部类匿名内部类</li></ol><h2>第三章 继承</h2><h1>重写和重载</h1><ul><li>重写方法的规则：</li></ul><p>1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p><p>2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。如果在子类中写了一个只有返回类型不同的函数，将不是重写，且会报错</p><p>3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p><p>4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p><p>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p><ul><li>而重载的规则：</li></ul><p>1、必须具有不同的参数列表；</p><p>2、可以有不责骂的返回类型，只要参数列表不同就可以了；</p><p>3、可以有不同的访问修饰符；</p><p>4、可以抛出不同的异常；</p><ul><li>重写与重载的区别在于：</li></ul><p>重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。</p><p>用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般.</p><p>重写是除了函数体其他必须完全相同，如果参数不同则是重载，如果参数相同而返回类型不同则会报错</p><h1>继承的初始化顺序</h1><p>1.初始化父类再初始化子类。2.先执行初始化对象中的属性，再执行构造方法中的初始化。父类对象--&gt;属性初始化---&gt;构造方法子类对象--&gt;属性初始化---&gt;构造方法</p><h1>父类与子类之间的调用顺序（打印结果）</h1><p>a) 父类静态代码块b) 子类静态代码块c) 父类构造方法d) 子类构造方法e) 子类普通方法f) 重写父类的方法，则打印重写后的方法</p><h1>inal关键字</h1><p>表示“最终的”，即不可修改。final可以修饰类、方法、属性和变量1、修饰类：不允许被继承2、修饰方法：不允许被重写3、修饰属性：则该属性不会进行隐式初始化（不会自动初始化），需要手动初始化或者在构造方法中初始化 （但二者只能选一，即只能初始化一次后便不能更改）4、修饰变量，只能在声明的时候赋一次值，成为常量。 （static final 会使其成为全局常量）</p><h1>super</h1><p>super关键字指的是父类子类的构造的过程当中必须调用其父类的构造方法 相当于super();默认是调用无参的如果子类的构造方法中没有显示调用父类的构造方法,系统会默认调用父类无参的构造方法.如果要显示的调用父类的构造方法,必须在子类的构造方法第一行中添加super();如果子类构造方法中既没有显示调用父类的构造方法,而父类又没有无参的构造方法,则编译出错,如果父类是定义了有参的构造方法,那么子类必须super.(父类的参数),或者父类中添加一个无参的构造方法,否则出错 因为默认调用的是super();是无参的。一个类中没有定义构造方法,则系统会默认为此类定义一个无参的构造方法.如果自定义了一个带参的构造方法,则系统不会为其添加无参的构造方法.</p><h1>Object方法</h1><p>视频只讲了2个方法。其实有12个方法。<code>Object()</code>默认构造方法<code>clone()</code>创建并返回此对象的一个副本。<code>equals(Object obj)</code>指示某个其他对象是否与此对象“相等”。<code>finalize()</code>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。<code>getClass()</code>返回一个对象的运行时类。<code>hashCode()</code>返回该对象的哈希码值。<code>notify()</code>唤醒在此对象监视器上等待的单个线程。<code>notifyAll()</code>唤醒在此对象监视器上等待的所有线程。<code>toString()</code>返回该对象的字符串表示。<code>wait()</code>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。<code>wait(long timeout)</code>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。<code>wait(long timeout, int nanos)</code>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p><h2>第四章 多态</h2><h1>多态： 指的是对象的多种形态</h1><p>主要分为 引用多态 、方法多态继承是多态的实现基础，别忘了子父类要有继承关系.多态特性：</p><ul><li>一、引用多态1.父类引用可以指向本类对象 Animal obj1 = new Animal();2.父类引用可以指向子类对象 Animal obj2 = new Dog();但是我们不能用子类的引用指向父类对象 Dog obj3 = new Animal();//错</li><li>二、方法多态1.在父类Animal中定义一个eat()方法，输出一个语句(动物有吃的能力); 在子类Dog中重写eat()方法，输出一个语句（狗是吃肉的）; 那么我们在测试类main函数里面，如果obj1.eat() ，那么调用的是父类的方法. 若用obj2调用eat()方法，那么调用的是子类的方法.2.还有一种情况，比如创建一个继承父类Animal的子类Cat ，但是Cat里并不重写继承的eat()方法. 然后，我们在测试类main函数里创建一个子类对象, Animal obj3 = new Cat(); 然后调用 obj3.eat(); 那么，结果调用的则是子类继承父类的方法. (输出结果：动物有吃的能力)3.最后一种特殊情况，多态的特性是不能使用的. 若在子类添加一个独有的方法 public void watchDoor() ，含有一句输出语句(狗具有看门的能力); 那么我们在测试类的main函数当中(得先定义好对象Animal obj2 = new Dog() )，就不能用obj2.watchDoor()，即不能通过父类的引用调用子类的方法.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总感觉java没有学好，重新看了一遍慕课上的java入门。想了一下还是自己做点笔记，概念的几天不看就容易忘。&lt;/p&gt;
&lt;h3&gt;java入门第一季&lt;/h3&gt;
&lt;p&gt;第一季都是一些简单的语法。有c语言基础，很快解决。&lt;/p&gt;
&lt;h3&gt;java入门第二季&lt;/h3&gt;
&lt;p&gt;第二季主
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java数组定义</title>
    <link href="http://yoursite.com/2018/03/29/java%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/03/29/java数组/</id>
    <published>2018-03-29T11:20:26.611Z</published>
    <updated>2018-03-29T11:24:23.231Z</updated>
    
    <content type="html"><![CDATA[<p>重拾java，忘了很多东西，特别是数组的定义老是会忘。记下来好了</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 数组的三种定义方法 </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * 1.数组类型[] 数组名=new 数组类型[数组长度];   </span></span><br><span class="line"><span class="comment">         * 2.数组类型[] 数组名=&#123;数组0,数组1,数组2,数组3,....&#125;;   </span></span><br><span class="line"><span class="comment">         * 3.数组类型[] 数组名=new 数组类型[]&#123;数组0,数组1,数组2,...&#125;;  </span></span><br><span class="line"><span class="comment">         * */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhatEver</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//第一种   例:  </span></span><br><span class="line">        String[] test1 = <span class="keyword">new</span> String[<span class="number">6</span>];  </span><br><span class="line">        test1[<span class="number">0</span>] = <span class="string">"数组0"</span>;  </span><br><span class="line">        test1[<span class="number">1</span>] = <span class="string">"数组1"</span>;  </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//第二种 例:  </span></span><br><span class="line">        String[] test2 = &#123;<span class="string">"数组0"</span>,<span class="string">"数组1"</span>,<span class="string">"数组2"</span>,<span class="string">"...."</span>&#125;;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//第三种 例:  </span></span><br><span class="line">        String[] test3 = <span class="keyword">new</span> String[]&#123;<span class="string">"数组0"</span>,<span class="string">"数组1"</span>,<span class="string">"数组2"</span>,<span class="string">"...."</span>&#125;;  </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重拾java，忘了很多东西，特别是数组的定义老是会忘。记下来好了&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>pat甲级感想</title>
    <link href="http://yoursite.com/2018/03/19/pat%E7%94%B2%E7%BA%A7%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2018/03/19/pat甲级感想/</id>
    <published>2018-03-19T12:30:36.360Z</published>
    <updated>2018-03-19T12:36:28.201Z</updated>
    
    <content type="html"><![CDATA[<p>昨天去考了pat的甲级，怎么说呢，在这里写下一些话警醒一下自己吧。其实如果按去年的水平来做的话甲级应该算还好吧，一些模拟题加算法和数据结构。这次一年多没刷题了，就在考前刷了几道，还是有很多水分的题目。考出这个结果也是意料之中的。考的时候一共4道题目，第一题看了很久居然都没有看懂是什么意思，第一题就花了将近一个半小时了，明明是很简单的模拟题。第二题也是感觉蛮简单的，就是后面有2个会超时的样例。第三题当模拟题做其实也可以做出来，但是当时就没有做了。想想ACM/PAT这种其实是很真实的，平时花了多少心思刷了多少题，学了多少，在比赛的时候很显而易见。会的就是会，不会就是不会。省赛打铁也是理所当然的。为什么？因为菜啊。希望接下来能继续努力吧。尽量每天都刷题。项目接下来也要做起来。求求你加油吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天去考了pat的甲级，怎么说呢，在这里写下一些话警醒一下自己吧。
其实如果按去年的水平来做的话甲级应该算还好吧，一些模拟题加算法和数据结构。
这次一年多没刷题了，就在考前刷了几道，还是有很多水分的题目。考出这个结果也是意料之中的。
考的时候一共4道题目，第一题看了很久居然
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2018/03/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2018/03/14/并查集/</id>
    <published>2018-03-14T11:15:52.462Z</published>
    <updated>2018-03-14T11:21:40.397Z</updated>
    
    <content type="html"><![CDATA[<p>想了想还是写上来好了，万一以后要看呢。转自：http://blog.csdn.net/niushuai666/article/details/6662911以 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">hdu1232</a> 畅通工程为例题目很简单，直接看并查集解释。并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">//存放第i个元素的父节点  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">//查找根结点  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> son, tmp;  </span><br><span class="line">    son = root;  </span><br><span class="line">    <span class="keyword">while</span>(root != pre[root])  <span class="comment">//寻找根结点  </span></span><br><span class="line">        root = pre[root];  </span><br><span class="line">    <span class="keyword">while</span>(son != root)  <span class="comment">//路径压缩  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        tmp = pre[son];  </span><br><span class="line">        pre[son] = root;  </span><br><span class="line">        son = tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">//判断是否连通，不连通就合并  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x, y;  </span><br><span class="line">    x = unionsearch(root1);  </span><br><span class="line">    y = unionsearch(root2);  </span><br><span class="line">    <span class="keyword">if</span>(x != y) <span class="comment">//如果不连通，就把它们所在的连通分支合并  </span></span><br><span class="line">        pre[x] = y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看码就能懂的。再把自己丑陋的畅通工程贴出来好了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> root[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> (pre[r]!=r)</span><br><span class="line">        r=pre[r];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i=x;</span><br><span class="line">    <span class="keyword">while</span> (i!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        j=pre[i];</span><br><span class="line">        pre[i]=r;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span> ( fx != fy )</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fx] = fy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            join( a , b );<span class="comment">//pre[a] = b;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>( root , <span class="number">0</span> , <span class="keyword">sizeof</span>(root) );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">            root[find(i)] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( root[i] == <span class="number">1</span> )</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="comment">/*for (int i = 1 ; i &lt; n ; i++ )</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if ( pre[i] != pre[i+1] )</span></span><br><span class="line"><span class="comment">                join(i , i + 1);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想了想还是写上来好了，万一以后要看呢。
转自：http://blog.csdn.net/niushuai666/article/details/6662911
以 &lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1232
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求树的前中后序遍历</title>
    <link href="http://yoursite.com/2018/03/10/%E6%B1%82%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2018/03/10/求树的前中后序遍历/</id>
    <published>2018-03-10T09:08:43.186Z</published>
    <updated>2018-03-13T03:39:38.419Z</updated>
    
    <content type="html"><![CDATA[<p>之前学树的时候学的很模糊也没有时间去弄懂，在pat上刷到题目不会写了，专门来学习一下已知另外两个遍历来求另一个遍历。</p><h3>已知前中序遍历求后序遍历。</h3><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">int <span class="keyword">in</span>[]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">int postnum[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">void</span> post(int root ,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start&gt;end)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    int i=start;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;end&amp;&amp;<span class="keyword">in</span>[i]!=pre[root])</span><br><span class="line">        i++;</span><br><span class="line">    post(root+<span class="number">1</span>,start,i<span class="number">-1</span>);</span><br><span class="line">    post(root+<span class="number">1</span>+(i-start),i+<span class="number">1</span>,end);</span><br><span class="line">    cout&lt;&lt;pre[root];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    post(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实想通了思想是比较简单的。首先先序遍历的第一个点必然是根节点。然后去中序遍历中找对应的根节点，将中序遍历分成左子树和右子树。此时对应的下标为i。对于左子树来说，根节点为root+i,需要遍历的最左子树下标为start，最右子树下标为i-1。右子树也一样。当start&gt;end即没有子树的情况下，输出即可。</p><h3>已知后中序遍历求先序遍历。</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> post[]=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> in[]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root ,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start&gt;end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;end&amp;&amp;post[root]!=in[i])</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;post[root];</span><br><span class="line">    pre(root-(end-i)<span class="number">-1</span>,start,i<span class="number">-1</span>);</span><br><span class="line">    pre(root<span class="number">-1</span>,i+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre(<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>求先序和求后序其实思想是一样的。无非是根节点的位置了。首先也是先找到根节点将中序遍历分为2个部分。然后对于这两个部分再分别去找对应的根节点。对于左子树来说，根节点为root-(end-i)-1，右子树来说为root-1。再遍历即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前学树的时候学的很模糊也没有时间去弄懂，在pat上刷到题目不会写了，专门来学习一下已知另外两个遍历来求另一个遍历。&lt;/p&gt;
&lt;h3&gt;已知前中序遍历求后序遍历。&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://yoursite.com/2018/03/09/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/03/09/写在前面/</id>
    <published>2018-03-09T12:17:31.785Z</published>
    <updated>2018-03-09T12:17:33.213Z</updated>
    
    <content type="html"><![CDATA[<p>其实早就想建一个个人blog了，去年也的确做了一点。在阿里云上买了一个服务器和2个域名。但是用阿里云体验实在有点差，镜像装的也颇麻烦。然后就发现了Github居然可以托管个人blog，搭建也是很方便，所以就有了这个地方。</p><p>还有一些屁话我也不想放了</p><p>希望自己可以加油吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实早就想建一个个人blog了，去年也的确做了一点。在阿里云上买了一个服务器和2个域名。但是用阿里云体验实在有点差，镜像装的也颇麻烦。然后就发现了Github居然可以托管个人blog，搭建也是很方便，所以就有了这个地方。&lt;/p&gt;
&lt;p&gt;还有一些屁话我也不想放了&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/09/hello-world/"/>
    <id>http://yoursite.com/2018/03/09/hello-world/</id>
    <published>2018-03-09T10:47:42.847Z</published>
    <updated>2018-03-09T10:47:42.850Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2>Quick Start</h2><h3>Create a new post</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3>Run server</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3>Generate static files</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3>Deploy to remote sites</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
